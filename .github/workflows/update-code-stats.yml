name: Update Code Stats and Years

on:
  schedule:
    - cron: '0 */3 * * *'  # Every 3 hours
  workflow_dispatch:

jobs:
  update-code-stats:
    name: Update Code Stats and Years in README
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GH_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Fetch and Update Code Stats
        uses: actions/github-script@v6
        env:
          WAKA_KEY: ${{ secrets.WAKA_KEY }}
        with:
          github-token: ${{ secrets.GH_TOKEN }}
          script: |
            const https = require('https');
            const fs = require('fs');
            const path = require('path');
            
            // Fetch WakaTime all_time stats (includes lines of code)
            // Reference: https://github.com/anmol098/waka-readme-stats
            async function fetchWakaStats() {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'wakatime.com',
                  path: '/api/v1/users/current/stats/all_time',
                  method: 'GET',
                  headers: {
                    'Authorization': `Bearer ${process.env.WAKA_KEY}`,
                    'Content-Type': 'application/json'
                  }
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    try {
                      const json = JSON.parse(data);
                      resolve(json);
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                
                req.on('error', reject);
                req.end();
              });
            }
            
            // Fetch all time since today (total coding hours)
            // Reference: https://github.com/anmol098/waka-readme-stats
            async function fetchAllTime() {
              return new Promise((resolve, reject) => {
                const options = {
                  hostname: 'wakatime.com',
                  path: '/api/v1/users/current/all_time_since_today',
                  method: 'GET',
                  headers: {
                    'Authorization': `Bearer ${process.env.WAKA_KEY}`,
                    'Content-Type': 'application/json'
                  }
                };
                
                const req = https.request(options, (res) => {
                  let data = '';
                  res.on('data', (chunk) => { data += chunk; });
                  res.on('end', () => {
                    try {
                      const json = JSON.parse(data);
                      resolve(json);
                    } catch (e) {
                      reject(e);
                    }
                  });
                });
                
                req.on('error', reject);
                req.end();
              });
            }
            
            // Calculate lines of code from GitHub commits (like waka-readme-stats does)
            // Reference: https://github.com/anmol098/waka-readme-stats
            async function calculateLinesFromGitHub() {
              try {
                // Get all repositories for the user
                const repos = await github.paginate(github.rest.repos.listForUser, {
                  username: 'oyi77',
                  per_page: 100,
                  type: 'all'
                });
                
                let totalAdditions = 0;
                let repoCount = 0;
                
                // Sample repositories to avoid rate limits (waka-readme-stats samples)
                const sampleSize = Math.min(repos.length, 100);
                const sampledRepos = repos.slice(0, sampleSize);
                
                for (const repo of sampledRepos) {
                  try {
                    // Get stats for this repository
                    const stats = await github.rest.repos.getContributorsStats({
                      owner: repo.owner.login,
                      repo: repo.name
                    });
                    
                    if (stats.data && Array.isArray(stats.data)) {
                      // Find contributions by oyi77
                      const myContribs = stats.data.find(c => c.author && c.author.login === 'oyi77');
                      if (myContribs && myContribs.weeks) {
                        const repoAdditions = myContribs.weeks.reduce((sum, week) => sum + (week.a || 0), 0);
                        totalAdditions += repoAdditions;
                        repoCount++;
                      }
                    }
                  } catch (repoError) {
                    // Skip if can't access repo stats
                    continue;
                  }
                }
                
                // Extrapolate if we sampled
                if (repos.length > sampleSize && repoCount > 0) {
                  const avgPerRepo = totalAdditions / repoCount;
                  totalAdditions = Math.floor(avgPerRepo * repos.length);
                }
                
                console.log(`Calculated from GitHub: ${totalAdditions} lines (sampled ${repoCount}/${repos.length} repos)`);
                return totalAdditions;
              } catch (error) {
                console.warn('GitHub API error for LOC calculation:', error.message);
                return 0;
              }
            }
            
            async function updateReadme() {
              try {
                // Read README first to extract existing values as fallback
                const readmePath = path.join(process.cwd(), 'README.md');
                let readmeContent = fs.readFileSync(readmePath, 'utf8');
                
                // Calculate years of experience from 2017-08-01
                const startDate = new Date('2017-08-01');
                const today = new Date();
                const yearsDiff = (today - startDate) / (1000 * 60 * 60 * 24 * 365.25);
                const yearsExperience = Math.floor(yearsDiff);
                const yearsText = `${yearsExperience}+`;
                
                console.log(`Calculated years of experience: ${yearsExperience} (from 2017-08-01)`);
                
                // Fetch from WakaTime API (same approach as waka-readme-stats)
                // Reference: https://github.com/anmol098/waka-readme-stats
                let linesOfCode = 0;
                let totalSeconds = 0;
                
                // First, try to extract from existing CODE_STATS section (if already populated)
                const codeStatsMatch = readmeContent.match(/<!--CODE_STATS:start-->[\s\S]*?<!--CODE_STATS:end-->/);
                if (codeStatsMatch) {
                  // Extract code time: Code%20Time-1%2C637%20hrs%2028%20mins
                  const codeTimeMatch = codeStatsMatch[0].match(/Code%20Time-([\d,]+)%2C(\d+)\s+hrs\s+(\d+)\s+mins/);
                  if (codeTimeMatch) {
                    const hours = parseInt(codeTimeMatch[1].replace(/,/g, ''), 10);
                    const mins = parseInt(codeTimeMatch[3], 10);
                    totalSeconds = (hours * 3600) + (mins * 60);
                    console.log(`Extracted from CODE_STATS: ${hours} hrs ${mins} mins`);
                  }
                  
                  // Extract lines of code: Written-35.65%20million
                  const locMatch = codeStatsMatch[0].match(/Written-([\d.]+)%20(million|thousand|K)/);
                  if (locMatch) {
                    const num = parseFloat(locMatch[1]);
                    const unit = locMatch[2].toLowerCase();
                    linesOfCode = unit.includes('million') ? Math.floor(num * 1000000) : 
                                 (unit.includes('thousand') || unit === 'k') ? Math.floor(num * 1000) : 
                                 Math.floor(num);
                    console.log(`Extracted from CODE_STATS: ${locMatch[1]} ${unit}`);
                  }
                }
                
                // If not found in CODE_STATS, fetch from APIs
                if (totalSeconds === 0 || linesOfCode === 0) {
                  try {
                    console.log('Fetching from WakaTime API...');
                    const stats = await fetchWakaStats();
                    const allTime = await fetchAllTime();
                    
                    // Extract total code time from all_time_since_today endpoint
                    // Reference: waka-readme-stats uses this for SHOW_TOTAL_CODE_TIME
                    if (allTime && allTime.data && totalSeconds === 0) {
                      totalSeconds = allTime.data.total_seconds || 0;
                      console.log(`Total seconds from WakaTime API: ${totalSeconds}`);
                    }
                    
                    // Calculate lines of code from GitHub commits (like waka-readme-stats)
                    // Reference: waka-readme-stats calculates this from GitHub when SHOW_LINES_OF_CODE=True
                    if (linesOfCode === 0) {
                      console.log('Calculating lines of code from GitHub commits...');
                      linesOfCode = await calculateLinesFromGitHub();
                      
                      // Fallback: Try WakaTime API if GitHub calculation fails
                      if (linesOfCode === 0 && stats && stats.data) {
                        console.log('GitHub calculation returned 0, trying WakaTime API...');
                        if (stats.data.lines) {
                          if (typeof stats.data.lines === 'object') {
                            linesOfCode = stats.data.lines.code || stats.data.lines.total || 0;
                          } else if (typeof stats.data.lines === 'number') {
                            linesOfCode = stats.data.lines;
                          }
                        }
                      }
                    }
                    
                  } catch (apiError) {
                    console.error('API error:', apiError.message);
                    // Keep existing values or 0
                  }
                }
                
                console.log(`Final Results - Lines: ${linesOfCode}, Total Seconds: ${totalSeconds}`);
                
                // Format lines of code (matching WAKA format: "35.65 million")
                let locFormatted = '';
                if (linesOfCode >= 1000000) {
                  const millions = (linesOfCode / 1000000).toFixed(2);
                  locFormatted = `${millions}%20million`;
                } else if (linesOfCode >= 1000) {
                  const thousands = (linesOfCode / 1000).toFixed(1);
                  locFormatted = `${thousands}K`;
                } else {
                  locFormatted = linesOfCode.toString();
                }
                
                const totalHours = Math.floor(totalSeconds / 3600);
                const totalMins = Math.floor((totalSeconds % 3600) / 60);
                
                // Format hours with comma separator for thousands (e.g., 1,637)
                const hoursFormatted = totalHours.toLocaleString();
                
                console.log(`Final values - Hours: ${totalHours}, Mins: ${totalMins}, LOC: ${locFormatted}`);
                
                // Format hours for badge (replace comma with %2C for URL encoding)
                const hoursForBadge = hoursFormatted.replace(/,/g, '%2C');
                
                // Create stats section (matching the format from WAKA section)
                // Using variable to avoid YAML parsing issues with ! character
                const imgPrefix = '!';
                const statsSection = '<!--CODE_STATS:start-->\n' +
                  imgPrefix + '[Code Time](http://img.shields.io/badge/Code%20Time-' + hoursForBadge + '%20hrs%20' + totalMins + '%20mins-blue?style=flat)\n\n' +
                  imgPrefix + '[Lines of code](https://img.shields.io/badge/From%20Hello%20World%20I%27ve%20Written-' + locFormatted + '%20lines%20of%20code-blue?style=flat)\n' +
                  '<!--CODE_STATS:end-->';
                
                // Check if CODE_STATS section exists
                const codeStatsRegex = /<!--CODE_STATS:start-->[\s\S]*?<!--CODE_STATS:end-->/;
                
                if (codeStatsRegex.test(readmeContent)) {
                  // Replace existing section
                  readmeContent = readmeContent.replace(codeStatsRegex, statsSection);
                } else {
                  // Insert before Professional Summary
                  const professionalSummaryRegex = /(## üë®‚Äçüíª Professional Summary)/;
                  readmeContent = readmeContent.replace(
                    professionalSummaryRegex,
                    statsSection + '\n\n$1'
                  );
                }
                
                // Update SEO Meta Description with dynamic years
                readmeContent = readmeContent.replace(
                  /(SEO Meta Description: TechLead & Full-Stack Developer with )\d+\+( years experience)/,
                  `$1${yearsText}$2`
                );
                
                // Update typing SVG URL with dynamic years (URL encoded %2B)
                const yearsEncoded = yearsText.replace('+', '%2B');
                readmeContent = readmeContent.replace(
                  /(readme-typing-svg\.demolab\.com\/\?lines=Full-stack%20Developer%20and%20app%20developer;Experienced%20IT%2FConsultant%20;)\d+%2B%20years%20of%20coding%20experience/,
                  `$1${yearsEncoded}%20years%20of%20coding%20experience`
                );
                
                // Update typing SVG alt text
                readmeContent = readmeContent.replace(
                  /(Professional title animation: Full-stack Developer, Experienced IT\/Consultant, )\d+\+( years coding experience)/,
                  `$1${yearsText}$2`
                );
                
                // Update Professional Summary with dynamic years
                readmeContent = readmeContent.replace(
                  /(\*\*TechLead & Full-Stack Developer\*\* with \*\*)\d+\+(\s+years of experience\*\*)/,
                  `$1${yearsText}$2`
                );
                
                // Update Python image alt text
                readmeContent = readmeContent.replace(
                  /(Python Programming Language - )\d+\+( years experience)/,
                  `$1${yearsText}$2`
                );
                
                // Update achievements section "5+ Years"
                readmeContent = readmeContent.replace(
                  /(\*\*)\d+\+(\s+Years\*\*)/g,
                  `$1${yearsText}$2`
                );
                
                // Update detailed achievements "5+ Years"
                readmeContent = readmeContent.replace(
                  /(\*\*)\d+\+(\s+Years\s+of\s+software)/,
                  `$1${yearsText}$2`
                );
                
                // Write updated README
                fs.writeFileSync(readmePath, readmeContent, 'utf8');
                
                // Commit and push
                const { execSync } = require('child_process');
                execSync('git config --local user.email "mbahkoe.pendekar@gmail.com"', { stdio: 'inherit' });
                execSync('git config --local user.name "oyi77"', { stdio: 'inherit' });
                execSync('git add README.md', { stdio: 'inherit' });
                
                try {
                  execSync('git diff --staged --quiet || git commit -m "‚ö° Update code stats and years of experience"', { stdio: 'inherit' });
                  execSync('git push', { stdio: 'inherit' });
                } catch (e) {
                  // No changes to commit
                  console.log('No changes to commit');
                }
                
              } catch (error) {
                console.error('Error updating README:', error);
                throw error;
              }
            }
            
            updateReadme();
